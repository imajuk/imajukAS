package com.imajuk.service {    import flash.events.EventDispatcher;    
    import flash.events.NetStatusEvent;        import flash.net.SharedObjectFlushStatus;        import flash.net.SharedObject;            /**     * @author yamaharu     */    public class SOService extends EventDispatcher    {        protected var appName:String;    	protected var propName:String;    	protected var so:SharedObject;    	        public function initialize(appName:String, propName:String, ...param):void
        {        	this.appName = appName;            this.propName = propName;        	        	try            {                so = SharedObject.getLocal(appName);            }            catch(e:Error)            {                trace("SharedObjectの生成または取得に失敗しました。");                return;            }            trace("SharedObject loaded...");        }                public function get data():String        {            return so.data[propName];        }                public function flush(value:String):Boolean         {//            trace("\tsaving value... ", value);            so.data[propName] = value;                        var flushStatus:String = null;            try             {                flushStatus = so.flush(10000);            }            catch (error:Error)             {                trace("Error...Could not write SharedObject to disk");                return false;            }            if (flushStatus != null)             {                switch (flushStatus)                 {                    case SharedObjectFlushStatus.PENDING:                        trace("\tRequesting permission to save object...");                        so.addEventListener(NetStatusEvent.NET_STATUS, onFlushStatus);                        return false;                        break;                    case SharedObjectFlushStatus.FLUSHED://                        trace("\tValue flushed to disk.\n");                        soFlushSuccessHook();                        return true;                        break;                }            }            return false;        }                public function clearValue():void         {            trace("so cleared");            delete so.data[propName];        }                private function onFlushStatus(event:NetStatusEvent):void         {            so.removeEventListener(NetStatusEvent.NET_STATUS, onFlushStatus);            trace("User closed permission dialog...");            switch (event.info["code"])             {                case "SharedObject.Flush.Success":                    trace("User granted permission -- value saved.");                    soFlushSuccessHook();                    break;                case "SharedObject.Flush.Failed":                    trace("User denied permission -- value not saved.");                    soFlushFailedHook();                    break;            }        }                protected function soFlushFailedHook():void        {        }        protected function soFlushSuccessHook():void        {        }
    }}