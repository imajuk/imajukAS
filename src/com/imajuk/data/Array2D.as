package com.imajuk.data {
	import flash.geom.Point;		import flash.utils.Dictionary;		import com.imajuk.data.Array2DIterator;	import com.imajuk.data.DiagonalIterator;	import com.imajuk.data.RoundHalfIterator;	import com.imajuk.data.IArray2DIterator;	import com.imajuk.data.ReverseIterator;		/**
	 * 2次元配列を表現するクラス	 * @author yamaharu
	 */
	public class Array2D 	{		private var _cells : Array;		private var _cols : int;		private var _dic : Dictionary;		public function Array2D (__cols : int = 0, __rows : int = 0, __elements : Array = null) 		{			_cells = new Array();			_cols = __cols;			_dic = new Dictionary();			for (var i : int = 0;i < __rows; i ++) 			{				_cells.push(new Array(__cols));			}			if(__elements && __elements.length > 0)			{				var j : IArray2DIterator = iterator();				while(j.hasNext())				{					setElement(j.cursorX, j.cursorY, __elements[j.position]);					j.next();				}			}		}						//---------------------------------------------------------------------------------getter/setter		/**		 * 2次元配列の水平方向の要素数		 * 現在の要素数を超える値を設定した場合には配列のサイズが拡張されます。		 * 現在の要素数より低い値を設定した場合は、配列が縮小され要素が切り詰められます。		 */		public function get cols () : int		{			return (_cells.length == 0) ? 0 : _cells[0].length;		}
						public function set cols (__c : int) : void		{            var i : int, a:Array, c:int = cols;                        for (i = 0;i < rows; i ++)             {                a = _cells[i];                if (__c < c)                    _cells[i] = a.slice(0, __c);                else    				a.length = __c;            }		}								/**		 * 2次元配列の垂直方向の要素数		 * 現在の要素数を超える値を設定した場合には配列のサイズが拡張されます。		 * 現在の要素数より低い値を設定した場合は、配列が縮小され要素が切り詰められます。		 */		public function get rows () : int		{			return _cells.length;
		}						public function set rows (__r : int) : void		{			var isRequireExpand : Boolean = (__r > rows);			if(isRequireExpand)			{				setElement(cols - 1, __r - 1, undefined);			}			else			{				_cells = _cells.splice(0, __r);			}		}								/**		 * 指定されたインデックスの要素を返します。		 * @param __x	取得したい要素の水平インデックス		 * @param __y	取得したい要素の垂直インデックス		 * @return		指定したインデックスに格納されている要素。		 * 				インデックスが配列のサイズ外であればnullを返します。		 * 				要素が未定義であればundefinedを返します。		 * 				nullとundefinedの違いに注意して下さい。		 */		public function getElement (__x : Number, __y : Number) : *		{			var r : Array = _cells[__y]; 			if(! r) return null;			if(r.length <= __x) return null;			return r[__x];		}						public function getElementByIndex (__index : int) : *		{			return _dic[__index];		}						/**		 * 指定したインデックスに要素を追加します。		 * @param __x	要素を追加する水平インデックス		 * @param __y	要素を追加する垂直インデックス		 * @return	なし		 */		public function setElement (__x : int, __y : int, __element : *) : void		{			if(_cols < __x) _cols = getMaxiumCol(__x + 1);			var isRequireFillCols : Boolean = (__y > rows);			//__y行めに行がまだなければ追加する			expandRow(__y, _cols);			//エレメントを格納			_cells[__y][__x] = __element;			_dic[__y * _cols + __x] = __element;						//必要があればセルをうめる			if(isRequireFillCols) fillEmptyRows();		}						/**		 * 全ての要素を走査するイテレータを返します。		 */		public function iterator () : IArray2DIterator		{			return new Array2DIterator(this);		}						/**		 * 全ての要素を逆順に走査するイテレータを返します。		 */		public function reverseIterator () : IArray2DIterator		{			return new ReverseIterator(this);		}						/**		 * 左上から右下までの対角線上にあるセルのイテレータを返します。		 * ■□□□		 * □■■□		 * □□□■		 */		public function diagonalIterator () : IArray2DIterator		{			return new DiagonalIterator(this);		}						public function u_r_Iterator () : IArray2DIterator		{			return new U_R_Iterator(this);		}						/**		 * 左上からスタートし、時計回りに右下のセルまで走査するイテレータを返す。		 * ■■■■■■■■■■■■■■■		 * □□□□□□□□□□□□□□■		 * □□□□□□□□□□□□□□■		 * □□□□□□□□□□□□□□■		 * □□□□□□□□□□□□□□■		 */		public function aroundHalfIterator () : IArray2DIterator		{			return new RoundHalfIterator(this);		}						/**		 * 全ての要素を直列につないで、1次元配列として返します。		 */		public function toArray () : Array		{			var a : Array = new Array();			for (var i : Number = 0;i < _cells.length; i ++) 			{				for (var j : Number = 0;j < _cells[i].length; j ++) 				{					a.push(_cells[i][j]);						}			}			return a;		}						//---------------------------------------------------------------------------------command				/**		 * 行を追加します。		 * @param __rows	追加する行数		 */		public function appendRows (__rows : int) : void		{			if(__rows < 1) return;			rows += __rows;		}						public function removeRow (__remove : int) : void		{			if(__remove < 1) return;			if(__remove >= rows) __remove = rows - 1;			rows -= __remove;		}						public function removeCol (__remove : Number) : void		{			if(__remove < 1) return;			if(__remove >= cols) __remove = cols - 1;			cols -= __remove;		}						public function appendCols (__cols : int) : void		{			if(__cols < 1) return;			cols += __cols;		}						/**		 * 全ての要素を標準出力に出力します。		 */		public function print () : void		{			trace("/************************");			trace(" * Array2D [cols=" + cols + ", rows=" + rows + "]");			for (var r : int = 0;r < _cells.length; r ++) 			{				var s : String = " * ";				for (var c : int = 0;c < _cells[r].length; c ++) 				{					s += _cells[r][c] + "\t";				}				trace(s);			}		}						//---------------------------------------------------------------------------------private				/**		 * n行めを追加する		 */		private function expandRow (__y : int, __cols : int) : void		{			if(isEmptyRow(__y)) _cells[__y] = new Array(__cols);		}						/**		 * n行めが空かどうかを返す		 */		private function isEmptyRow (__y : int) : Boolean		{			return _cells[__y] == undefined;		}						/**		 * 未定義の行をうめる。		 */		private function fillEmptyRows () : void		{			for (var i : Number = 0;i < _cells.length; i ++) 			{				expandRow(i, _cols);			}		}						/**		 * 行を走査し、最大の要素数を返す		 */		private function getMaxiumCol (__x : int) : int		{			var c : int = 0;			for (var i : int = 0;i < rows; i ++) 			{				var l : int = (_cells[i] == undefined) ? 0 : _cells[i].length;				c = (c < l) ? l : c;			}			return (c > __x) ? c : __x;		}						public function get size () : int		{			return cols * rows;		}
						/**		 * 指定された列の全てのエレメントを返す		 */
		public function getColElement (__x : int) : Array
		{			var a : Array = new Array();			for (var i : Number = 0;i < rows; i ++) 			{				a.push(_cells[i][__x]);			}			return a;		}
						/**		 * 指定された行の全てのエレメントを返す		 */
		public function getRowElement (__y : int) : Array
		{			var a : Array = new Array();			for (var i : Number = 0;i < cols; i ++) 			{				a.push(_cells[__y][i]);			}			return a;
		}
						public function shiftDown (__value : int = 1, __repeat : Boolean = false) : Array2D
		{			var result : Array2D = new Array2D();			var c : Array = _cells.concat();			var remove : Array = c.splice(0, c.length - __value);			var top : Array = (__repeat) ? c.concat() : getEmptyRows(__value);			result._cells = top.concat(remove);			return result;
		}						public function shiftUp (__value : int = 1, __repeat : Boolean = false) : Array2D		{			var result : Array2D = new Array2D();			var c : Array = _cells.concat();			var remove : Array = c.splice(__value);			var left : Array = (__repeat) ? c.concat() : getEmptyRows(__value);			result._cells = remove.concat(left);			return result;		}						public function shiftLeft (__value : int = 1, __repeat : Boolean = false) : Array2D		{			var result : Array2D = new Array2D();			result._cells = _cells.concat().map(function(a:Array, ...param):Array			{				var left : Array = a.splice(__value);				var right : Array = (__repeat) ? a.concat() : new Array(__value).map(function():Array				{					return undefined;				});				return left.concat(right);			});			return result;		}						public function shiftRight (__value : int = 1, __repeat : Boolean = false) : Array2D		{			var result : Array2D = new Array2D();			result._cells = _cells.concat().map(function(a:Array, ...param):Array			{				var right : Array = a.splice(0, a.length - __value);				var left : Array = (__repeat) ? a.concat() : new Array(__value).map(function():Array				{					return undefined;				});				return left.concat(right);			});			return result;		}						/**		 * n行の空白のセルを生成して返します。列数は現在の列数となります。		 * @param __value	生成したい行数		 */		private function getEmptyRows (__value : int) : Array		{			var a : Array = new Array(__value).map(function():Array			{				return new Array(_cols).map(function():Array				{					return undefined;				}); 			});			return a;		}
						public function getIndexByPosition (__x : int, __y : int) : int
		{			var x : int = (__x == 0) ? 0 : __x % cols;			return cols * __y + x;
		}						public function getPositionByIndex (__index : int) : Point		{			var x : int = __index % _cols;			var y : int = __index / _cols;			return new Point(x, y);		}
						public function map (__mapterator : IArray2DIterator) : Array2D
		{			var a : Array2D = new Array2D(cols, rows);			var src : IArray2DIterator = iterator();			var map : IArray2DIterator = __mapterator;			while(map.hasNext())			{				var x : int = map.cursorX;				var y : int = map.cursorY;				var m:* = src.next();				a.setElement(x, y, m);				map.next();			}			return a;
		}						public function spliceCols (__start : int, __length : int) : Array2D		{			if(cols <= __length)				return null;							var spliced : Array = [];			var result : Array = [];			for (var j : int = 0;j < rows; j ++) 			{				var row : Array = getRowElement(j);				var remove : Array = row.splice(__start, __length);				spliced = spliced.concat(remove);				result = result.concat([ row ]);			}			_cells = result;			return new Array2D(__length, rows, spliced);		}						public function concat (__add : Array2D) : Array2D		{			var row : Array;			var result : Array = [];			for (var j : int = 0;j < rows; j ++) 			{				row = getRowElement(j);				result = result.concat([ row.concat(__add.getRowElement(j)) ]);			}			_cells = result;			return this;		}
	}
}
