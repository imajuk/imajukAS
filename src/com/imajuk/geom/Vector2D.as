package com.imajuk.geom {    import flash.utils.Dictionary;
    import flash.geom.Point;        /**     * @author yamaharu     */    public class Vector2D     {    	//=================================    	// 誤差吸収用テーブル    	//=================================        private static const DEGREES_30 : Number = 0.5235987755982988;        private static const DEGREES_45 : Number = 0.7853981633974483;
        private static const DEGREES_90 : Number = Math.PI * .5;
        private static const DEGREES_135 : Number = 2.356194490192345;        private static const DEGREES_150 : Number= 2.6179938779914944;
        private static const SQRT_2 : Number = Math.SQRT2;        private static const SQRT_3 : Number = 1.7320508075688772;
        private static var tableX : Dictionary;
        private static var tableY : Dictionary;
        //--------------------------------------------------------------------------        //        //  Class methods        //        //--------------------------------------------------------------------------		//=================================		// the factory method		//=================================        /**         * 2次元ベクトルを生成します.         * <p>         * Vecor2Dインスタンスの生成は、コンストラクタを使用する以外に         * 任意のPointから生成できるVector2D.createFromPoint()があります.         * Vector2D.createFromPoint()の方が高速にインスタンスを生成できます.</p>         * @param theta	ベクトルの向きをラジアン度で渡します.         * @param velocity	ベクトルの強さ.         * @param startPosition	ベクトルの始点         */        public static function create(angle : Number, velocity : Number = 1) : Vector2D         {            var v : Vector2D = new Vector2D();            v._angle = angle;            v._velocity = velocity;            v._vx = NaN;            v._vy = NaN;            return v;        }        /**		 * 任意の点から2次元ベクトルを生成します.		 * 引数として渡す点はベクトルの終点、またはベクトルの始点と終点です.		 * 終点のみを渡す場合は始点は座標（0,0）となります。		 * @param p1	2次元ベクトルの終点、または始点		 * @param p2	2次元ベクトルの終点		 * @return		2次元ベクトル		 */        public static function createFromPoint(p1:Point, p2:Point = null):Vector2D        {	        var v:Vector2D = new Vector2D();   	        if (p2)	        {                v._vx = p2.x - p1.x;	                v._vy = p2.y - p1.y;	            }            else            {                v._vx = p1.x;                v._vy = p1.y;            }            v._velocity = NaN;            v._angle = NaN;            return v;        }        //--------------------------------------------------------------------------        //        //  Constructor        //        //--------------------------------------------------------------------------        /**         * コンストラクタ.         *          * <p>ゼロ2次元ベクトルを生成します.<br/>         * 方向と強さからベクトルを生成する場合はVector2D.create()を、         * 任意のPointから生成する場合はVector2D.createFromPoint()を使用します.</p>         */        public function Vector2D()         {        	//=================================            // Math.cos(_angle) * _velocityの計算時に誤差が出てしまうので            // 特定のangle,verocity時に限りテーブルを使ってvx,vyを求める.            //=================================            //テーブルがなければ作成            if (!tableX)                internalInit();        }        private function internalInit() : void         {            tableX = new Dictionary(true);            tableX[-DEGREES_30] = new Dictionary(true);            tableX[-DEGREES_45] = new Dictionary(true);            tableX[-DEGREES_150] = new Dictionary(true);            tableX[DEGREES_30] = new Dictionary(true);            tableX[DEGREES_45] = new Dictionary(true);            tableX[Math.PI] = new Dictionary(true);            tableX[DEGREES_150] = new Dictionary(true);            tableX[DEGREES_90] = 0;            tableX[-DEGREES_90] = 0;                            tableX[-DEGREES_30][2] = SQRT_3;            tableX[-DEGREES_45][SQRT_2] = 1;            tableX[-DEGREES_150][2] = -SQRT_3;            tableX[DEGREES_30][2] = SQRT_3;            tableX[DEGREES_45][SQRT_2] = 1;            tableX[Math.PI][SQRT_2] = -SQRT_2;            tableX[DEGREES_150][2] = -SQRT_3;                            tableY = new Dictionary(true);            tableY[-DEGREES_30] = new Dictionary(true);            tableY[-DEGREES_45] = new Dictionary(true);            tableY[-DEGREES_90] = new Dictionary(true);            tableY[-DEGREES_135] = new Dictionary(true);            tableY[-DEGREES_150] = new Dictionary(true);            tableY[DEGREES_30] = new Dictionary(true);            tableY[DEGREES_45] = new Dictionary(true);            tableY[DEGREES_90] = new Dictionary(true);            tableY[DEGREES_135] = new Dictionary(true);            tableY[DEGREES_150] = new Dictionary(true);                            tableY[-DEGREES_30][2] = -1;            tableY[-DEGREES_45][SQRT_2] = -1;            tableY[-DEGREES_90][SQRT_2] = -SQRT_2;            tableY[-DEGREES_135][SQRT_2] = -1;            tableY[-DEGREES_150][2] = -1;            tableY[DEGREES_30][2] = 1;            tableY[DEGREES_45][SQRT_2] = 1;            tableY[DEGREES_90][SQRT_2] = SQRT_2;            tableY[DEGREES_135][SQRT_2] = 1;            tableY[DEGREES_150][2] = 1;            tableY[Math.PI] = 0;            tableY[-Math.PI] = 0;        }
        //--------------------------------------------------------------------------        //        //  properties        //        //--------------------------------------------------------------------------        /**         * 2次元ベクトルのベロシティです         * このプロパティを変更するとvx, vyプロパティも変更されます.         */        private var _velocity:Number = 0;        public function get velocity():Number        {            if (isNaN(_velocity))                validate2();            return _velocity;        }        public function set velocity(value:Number):void        {            if ((_velocity > 0 && value < 0) || (_velocity < 0 && value > 0))                _angle *= -1;                            _velocity = value;            _vx = NaN;            _vy = NaN;        }        /**         * 2次元ベクトルの角度です         * このプロパティを変更するとvx, vyプロパティも変更されます.         */        private var _angle:Number = 0;        public function get angle():Number        {        	if (isNaN(_angle))        	   validate2();            return _angle;        }        public function set angle(value:Number):void        {            _angle = value;            _vx = NaN;            _vy = NaN;        }        /**         * 終点のデカルト座標を返します         * 戻り値に特にPointを必要としない場合は         * vx, vyプロパティにアクセスする方が多分わずかに高速です.         */		private var _coordinate:Point;        public function get coordinate():Point        {        	_coordinate = new Point(vx, vy);            return _coordinate;        }                /**         * 2次元ベクトルのx成分です         */        private var _vx : Number = 0;        public function get vx() : Number        {        	if (isNaN(_vx))        	   validate();            return _vx;        }        public function set vx(value : Number) : void        {            _vx = value;            _velocity = NaN;            _angle = NaN;        }        /**         * 2次元ベクトルのy成分です         */        private var _vy : Number = 0;        public function get vy() : Number        {        	if (isNaN(_vy))        	   validate();            return _vy;        }        public function set vy(value : Number) : void        {            _vy = value;            _velocity = NaN;            _angle = NaN;        }                //--------------------------------------------------------------------------        //        //  Methods        //        //--------------------------------------------------------------------------        //=================================        // for trace()        //=================================        public function toString():String         {            return 	 "Vector2D[" +             		 " angle:" + angle +            		 " velocity:" + velocity +            		 " des" + coordinate +             		 "]";        }                //=================================        // operations        //=================================        /**		 * ベクトルの加算.		 * 加算されたベクトルの始点は（0,0）である事に注意.		 */        public function add(v:Vector2D):Vector2D        {            return createFromPoint(new Point(vx + v.vx, vy + v.vy));        }        /**         * 2つのベクトルのなす角を求める         */        public function getRadiansWith(v : Vector2D) : Number        {            var cos : Number = normalize().dotProduct(v.normalize());             return Math.acos(cos);        }        /**         * 2つのベクトルのなす角を求める（方向付き）         */        public function getRadiansWith2(v : Vector2D) : Number         {        	var n:Vector2D = normalize();        	return Math.atan2(n.crossProduct(v), n.dotProduct(v));        }        /**         * ベクトルの内積を返します         */        public function dotProduct(v:Vector2D):Number        {            return vx * v.vx + vy * v.vy;        }        /**         * ベクトルの外積を返します         */        public function crossProduct(v : Vector2D) : Number         {            return vx * v.vy - v.vx * vy;        }        /**         * 任意の2次元ベクトルと等しいかどうかを返します         */        public function equals(v:Vector2D):Boolean        {            return vx == v.vx && vy == v.vy;        }        /**         * 2次元ベクトルを正規化した新しいベクトルを返します.         */        public function normalize():Vector2D        {            return Vector2D.create(angle);        }        /**         * 2次元ベクトルの複製を返します         */        public function clone():Vector2D        {        	var v:Vector2D = Vector2D.createFromPoint(new Point(vx, vy));        	v.validate2();             return v;        }        /**         * 2次元ベクトルを回転します         * このメソッドはvx, vy, angleプロパティを変更します         * @param value 現在の角度に加えるラジアン度         */        public function rotate(value:Number):Vector2D        {            angle += value;            validate();            return this;        }        /**         * angleとverocityからvx,vyを計算する         * テーブルがある場合はテーブルの値を使用する         */        private function validate():void        {        	var v:Number = _velocity;            var a:Number = _angle;        	var n:Number = Number(tableX[a]);            if(isNaN(n))            {            	if (tableX[a] is Dictionary)            	{            		n = Number(tableX[a][v]);            		if (isNaN(n))                        _vx = Math.cos(a) * v;                    else                        _vx = n;            	}            	else                {                    _vx = Math.cos(a) * v;                }            }            else            {            	_vx = n;            }                    	n = Number(tableY[a]);            if(isNaN(n))            {                if (tableY[a] is Dictionary)                {                    n = Number(tableY[a][v]);                    if (isNaN(n))                        _vy = Math.sin(a) * v;                    else                        _vy = n;                }                else                {                    _vy = Math.sin(a) * v;                }            }            else            {                _vy = n;            }        }        //=================================        // calcuration for angle and verocity        //=================================        private function validate2() : void         {        	_velocity = Math.sqrt(_vx * _vx + _vy * _vy);            _angle = Math.atan2(_vy, _vx);        }        public function isZeroVector() : Boolean        {            return vx == 0 && vy == 0;        }        public function isHolizonal() : Boolean        {            return vx != 0 && vy == 0;        }        public function isVertical() : Boolean        {            return vx == 0 && vy != 0;        }    }}