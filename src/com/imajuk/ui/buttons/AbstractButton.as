package com.imajuk.ui.buttons {    import com.imajuk.behaviors.BehaviorDetail;    import com.imajuk.behaviors.IButtonBehavior;    import com.imajuk.constructions.AssetWrapper;    import com.imajuk.interfaces.IDisplayObjectWrapper;    import com.imajuk.logs.Logger;    import com.imajuk.ui.IUIView;    import com.imajuk.ui.buttons.fluent.BehaviorFluent;    import com.imajuk.ui.buttons.group.ButtonGroup;    import flash.display.DisplayObject;    import flash.display.DisplayObjectContainer;    import flash.display.Sprite;    import flash.events.MouseEvent;    import flash.media.Sound;    /**     * 抽象ボタンクラス.     *      * AbstractButtonはIButton, IDisplayObjectWrapperを実装します。     * ボタンはコンストラクタでアセットが渡されると自身のコンテナにアセットを再配置します。     * 既にステージに配置されているアセットを渡す時には     * クライアントが直接このクラスのコンストラクタを呼び出してインスタンス化することは推奨されません。     * AbstractButton.wrap()、または     * AbstractButton.wrapByName()を使用してください。     * （これはアセットのラップに関する問題によるものです。     * 詳細は、https://www.assembla.com/wiki/show/imajukAsLib/DisplayObjectの生成、レイアウトに関して     * 「表示リストに既に含まれたアセットに関して」を参照してください。）     * AbstractButton.wrapByName()の戻り値は複数のAbstractButtonを要素にもつButtonGroupです.     * ButtonGroupは複数のAbstractButtonのプロパティを一度に変更したり、     * 排他的ボタングループを作成するために利用できます.     *      * @author shinyamaharu     */    public class AbstractButton extends Sprite implements IButton, IDisplayObjectWrapper, IUIView    {        protected var _invorker : BehaviorInvoker;        protected var _utils : ButtonUtils;        protected var _targetAsset : DisplayObject;        private var _fluent : BehaviorFluent;        private var _ignore : Array = [];                public static function get globalClickSound() : Sound        {            return BehaviorInvoker.globalClickSound;        }        public static function set globalClickSound(sound : Sound) : void        {            BehaviorInvoker.globalClickSound = sound;        }        public static function get globalOverSound() : Sound        {            return BehaviorInvoker.globalOverSound;        }        public static function set globalOverSound(sound : Sound) : void        {            BehaviorInvoker.globalOverSound = sound;        }        /**         * コンストラクタ         * AbstractButtonを生成するには、2通りの方法があります.         * ひとつは以下のようにnew演算子を使用する方法、         * var button:AbstractButton = new AbstractButton(button_asset);         * もうひとつは以下のようにファクトリメソッドを使用する方法です.         * var button:AbstractButton = AbstractButton.wrap(button_asset);         * var button:AbstractButton = AbstractButton.wrapByName(container, button_name);         * AbstractButton生成時に、ボタンアセットが何らかのコンテナ内に配置されている場合は         * ファクトリメソッドを使用してAbstractButtonを生成する事が推奨されています.         * これはアセットのラップに関する諸問題に対応し、正しくボタンクラスを生成するためです。         * 詳細は、http://www.assembla.com/wiki/show/imajukAsLib/UILib_policy         * のprinciple2を参照してください。         */        public function AbstractButton(asset:DisplayObject)         {            _asset = addChild(asset);                        _utils = new ButtonUtils();            _utils.recordInteractiveStatus(this);            _invorker = new BehaviorInvoker(this);            _fluent = new BehaviorFluent(this);                        buttonMode = true;            mouseChildren = false;            tabEnabled = false;            tabChildren = false;        }                override public function toString() : String        {            return "AbstractButton[" + id + "]";        }                //--------------------------------------------------------------------------        //  Factory methods        //--------------------------------------------------------------------------        public static function wrap(asset:DisplayObject, buttonID:int = int.MAX_VALUE) : IButton        {            var container:DisplayObjectContainer = asset.parent;            if (!container)                throw new Error("AbstractButton.wrap()を使用してアセットをボタンでラップする場合は、アセットは表示リストに含まれている必要があります.");            else if(container != asset.parent)                throw new Error(asset + "をボタンでラップしようとしましたが失敗しました.\n" +                    "アセット[" + asset.name + "]はコンテナ[" + container.name + "]に配置されてなければなりません.\n" +                    "単にボタンを生成する場合はnew演算子を使用してください.");                                return wrapByName(container, asset.name, Vector.<int>([buttonID]));        }                /**         * @param container         */        public static function wrapByName(                                    container : DisplayObjectContainer,                                     assetsName : String,                                    ids:Vector.<int> = null                               ) : IButton         {            var btns:Array =               AssetWrapper.wrapAsDisplayObjectByName(                        container,                         assetsName,                         true,                         AbstractButton                    );                         if (ids)                btns.forEach(function(b : AbstractButton, idx : int, ...pram) : void                {                    try                    {                        if (ids[idx] != int.MAX_VALUE)                            b.id = ids[idx];                    }                    catch(e : Error)                    {                        trace("ComplexButtonにidを設定する過程でエラーがおきました", idx, ids);                    }                });                        if (btns.length == 0)                throw new Error("ボタンの生成に失敗しました.");            else if (btns.length == 1)                return btns[0];            else                return container.addChild(new ButtonGroup(btns)) as ButtonGroup;        }        //--------------------------------------------------------------------------        //  API (IButton Implementation)        //--------------------------------------------------------------------------        private var _id:int;        public function get id() : int        {            return _id;        }        public function set id(value : int) : void        {            _id = value;        }                private var _selected:Boolean;        public function get selected() : Boolean        {            return _selected;        }        public function set selected(value : Boolean) : void        {            _selected = value;                        if (_selectable)            {                if (_selected)                    _invorker.behaveSelected();                else                    _invorker.behaveUnSelected();            }        }                private var _selectable:Boolean;        public function get selectable() : Boolean        {            return _selectable;        }        public function set selectable(value : Boolean) : void        {        	_selectable = value;        }                private var _toggle:Boolean;        public function get toggle() : Boolean        {            return _toggle;        }        public function set toggle(value : Boolean) : void        {            _toggle = value;        }                public function get behaviorDetail() : BehaviorDetail        {            return _invorker.button_internal::behaviorDetail;        }        public function set behaviorDetail(value : BehaviorDetail) : void        {            _invorker.button_internal::behaviorDetail = value;        }        override public function set mouseEnabled(value:Boolean):void        {            super.mouseEnabled = value;            if (value)                _invorker.behaveEnable();            else                _invorker.behaveDisable();        }                public function start() : void        {            //check confrict            _invorker.button_internal::checkConfrict();                        buttonMode = true;                        stopInteraction();            startInteraction();        }                public function stop() : void        {            buttonMode = false;                     stopInteraction();            _utils.revertInteractiveStatus(this);        }        public function virtualClick() : void        {            dispatchEvent(new MouseEvent(MouseEvent.CLICK, true, false));        }                public function rollOverEffect() : void        {            _invorker.behaveRollOver(true);        }                public function rollOutEffect() : void        {            _invorker.behaveRollOut(true);        }                public function upEffect() : void        {            _invorker.behaveUp();        }                public function removeBehaviorAll() : void        {            _invorker.button_internal::removeBehaviorAll();        }                //--------------------------------------------------------------------------        //  IBehaviorFluentAPI Implementation        //--------------------------------------------------------------------------        public function context(contextType : String) : IButton        {            return _fluent.context(contextType);        }        public function behave(behavior : IButtonBehavior) : IButton        {            return _fluent.behave(behavior);        }                public function sound(sound : Sound) : IButton        {            return _fluent.sound(sound);        }        //--------------------------------------------------------------------------        //  IDisplayObjectWrapper Implementation        //--------------------------------------------------------------------------        protected var _asset : DisplayObject;        public function get asset() : DisplayObject        {            return _asset;        }                //--------------------------------------------------------------------------        //  IUIView Implementation        //--------------------------------------------------------------------------        public function get actualHeight() : int        {        	return height;        };        public function set actualHeight(value : int) : void        {        	height = value;        }        public function get externalHeight() : int        {        	return height;        };        public function set externalHeight(value : int) : void        {        	height = value;        }        public function get externalWidth() : int        {        	return width;        };        public function set externalWidth(value : int) : void        {            width = value;        }                public function get externalX() : int        {            return x;        };        public function get externalY() : int        {        	return y;        };                //--------------------------------------------------------------------------        //  API (AbstractButton Implementation)        //--------------------------------------------------------------------------        public function getBehaviors(context : String) : Array        {            return _invorker.button_internal::getBehavior(context);        }        public function lockBehaviors() : void        {            _invorker.lock = true;        }        public function unlockBehaviors() : void        {            _invorker.lock = false;        }        /**         * rollout判定時に、rolloutとみなさないボタンを登録します.         * たとえば、大きなボタンの上に小さなボタンがあるケースで、         * 小さなボタンのrollover時に大きなボタンのrolloutが発生しますが         * これを無視するために、大きなボタンのignoreRollOutOn()メソッドに         * 小さなボタンを渡します.         */        public function ignoreRollOutOn(ignoreButton : IButton) : void        {            _ignore.push(ignoreButton);        }                //--------------------------------------------------------------------------        //  event handlers        //--------------------------------------------------------------------------        private function overHandler(event : MouseEvent) : void        {            _invorker.behaveRollOver();        }                private function outHandler(e : MouseEvent) : void        {            if (!_ignore.some(                    function(b : IButton, ...param):Boolean                    {                        return b && Sprite(b).hitTestPoint(e.stageX, e.stageY, true);                    }                ))                _invorker.behaveRollOut();        }                private function downHandler(event : MouseEvent) : void        {            _invorker.behaveDown();        }                private function upHandler(event : MouseEvent) : void         {            _invorker.behaveUp();                        if (!selectable)                return;            //トグルボタンなら自動的にトグル            if (_toggle)                _selected = !_selected;            else                _selected = true;                        if (_selected)                _invorker.behaveSelected();            else                _invorker.behaveUnSelected();        }                //--------------------------------------------------------------------------        //  Internal API        //--------------------------------------------------------------------------        button_internal function applyBehaviorToContext(behavior : IButtonBehavior, contextType : String) : void        {            _invorker.button_internal::applyBehaviorToContext(behavior, contextType);        }        button_internal function applySoundToContext(sound : Sound, contextType : String) : void        {            _invorker.button_internal::applySoundToContext(sound, contextType);        }                button_internal function initTargetAsset(specTarget : *) : DisplayObject        {            _targetAsset = solveParamAsDisplayObject(_asset, specTarget);            return _targetAsset;        }                //--------------------------------------------------------------------------        //  private        //--------------------------------------------------------------------------        private function startInteraction() : void        {            addEventListener(MouseEvent.ROLL_OVER,  overHandler);            addEventListener(MouseEvent.ROLL_OUT,   outHandler);            addEventListener(MouseEvent.MOUSE_DOWN, downHandler);            addEventListener(MouseEvent.MOUSE_UP,   upHandler);        }                private function stopInteraction() : void        {            removeEventListener(MouseEvent.MOUSE_OVER, overHandler);            removeEventListener(MouseEvent.MOUSE_OUT,  outHandler);            removeEventListener(MouseEvent.MOUSE_DOWN, downHandler);            removeEventListener(MouseEvent.MOUSE_UP,   upHandler);        }                /**         * 引数をDisplayObjectとして解決する         * (Stringを渡した時はアセットからその名前のDisplayObjectを返す)         */        private function solveParamAsDisplayObject(container : DisplayObject, param : *) : DisplayObject         {            var result : DisplayObject;                        if (param == null)                result = container;            else if (param is DisplayObject)                result = param;            else if (param is String && container is Sprite)                result = Sprite(container).getChildByName(param);            else                new Error(this + "のassetの取得に失敗しました. 不正なオブジェクトが渡されました.");                        if (!result)            {                Logger.warning(                    this + "のassetの取得に失敗しました. " +                     param + "が渡されましたがそのようなDisplayObjectは" +                     container + "(" + container.name + ")" + "内に存在しません."                );            }                            return result;        }    }}