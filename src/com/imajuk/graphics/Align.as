package com.imajuk.graphics {    import com.imajuk.data.LinkList;    import com.imajuk.data.LinkListNode;    import com.imajuk.testImajuk;    import com.imajuk.utils.DisplayObjectUtil;    import com.imajuk.utils.StageReference;    import flash.display.DisplayObject;    import flash.display.DisplayObjectContainer;    import flash.display.Stage;    import flash.events.Event;    import flash.events.FullScreenEvent;    /**     * DisplayObjectのレイアウトを支援するクラス     * 
     * @author yamaharu
     */
    public class Align     {        public static const BOTH : String = "BOTH";        private static var _auto : LinkList = new LinkList();        
        public static function get Top():IALignAction        {             return new AlignT();        };
        public static function get TopLeft():IALignAction        {             return new AlignTL();        };
        public static function get TopRight():IALignAction        {            return new AlignTR();        };        public static function get Left():IALignAction        {             return new AlignL();        };        public static function get Center():IALignAction        {             return new AlignC();        };        public static function get Right():IALignAction        {             return new AlignR();        };                public static function get Bottom():IALignAction        {            return new AlignB();        };                public static function get BottomLeft():IALignAction        {            return new AlignBL();        };                public static function get BottomRight():IALignAction        {            return new AlignBR();        };
        private var target:DisplayObject;        private var coordinateSpace:AlignCoordinateSpace;        private var action:IALignAction;
        /**         * 任意のDisplayObjectを整列させます。         * 整列の基準になるオブジェクトはデフォルトでStageです。         * 整列の基準になるオブジェクトを変更するにはalong()を使用します.         *          * @param displayObject 整列の対象となるオブジェクト         * @param direction     整列の方向         */        public static function align(displayObject:DisplayObject, direction:IALignAction):Align        {            if (!StageReference.isEnabled)                throw new AlignError(AlignError.UNINITIALIZATION, AlignError.UNINITIALIZATION_ID);                            if (displayObject is Stage)                throw new AlignError(AlignError.INVALID_TARGET_STAGE, AlignError.INVALID_TARGET_STAGE_ID);                            if (!displayObject.stage)                throw new AlignError(AlignError.INVALID_TARGET_DISPLAYLIST, AlignError.INVALID_TARGET_DISPLAYLIST_ID);            if (DisplayObjectUtil.isStageChild(displayObject) && displayObject.root == displayObject)                throw new AlignError(AlignError.INVALID_TARGET_DOCUMENTCLASS, AlignError.INVALID_TARGET_DOCUMENTCLASS_ID);                            return new Align(displayObject, direction);
        }
        public function Align(target:DisplayObject, action:IALignAction)         {            this.target = target;            this.action = action;            this.coordinateSpace = new AlignCoordinateSpace(StageReference.stage);            execute();        }
        public function along(coordinate:DisplayObjectContainer):Align        {            if (target == coordinate)                throw new AlignError(AlignError.INVALID_CONTAINER_SAMEASTARGET, AlignError.INVALID_CONTAINER_SAMEASTARGET_ID);                            if (coordinate.width == 0 || coordinate.height == 0)                throw new AlignError(AlignError.INVALID_CONTAINER_NOSIZE, AlignError.INVALID_CONTAINER_NOSIZE_ID);                            if (coordinate.contains(target) && coordinate.numChildren == 1)                throw new AlignError(AlignError.INVALID_CONTAINER_LESSCHILD, AlignError.INVALID_CONTAINER_LESSCHILD_ID, coordinate.name);                        coordinateSpace = new AlignCoordinateSpace(coordinate);            execute();            return this;        }
        public function execute():void        {            if (!target.stage) return;                        action.execute(target, coordinateSpace);                        target.x = Math.round(target.x);            target.y = Math.round(target.y);        }
        
        public function withOffsetH(offset:Number):Align
        {
        	action.offsetH = offset;        	execute();        	return this;        }                public function withOffsetV(offset:Number):Align        {        	action.offsetV = offset;            execute();        	return this;        }        testImajuk function getCoordinateSpace():DisplayObjectContainer        {            return coordinateSpace.container;        }        /**         * Stageのリサイズ時に自動実行します         */        public function auto() : void        {            if (_auto.length == 0)            {                var s:Stage=StageReference.stage,                    f:Function =                         function(...param) : void                        {                            var n:LinkListNode = _auto.first;                            while(n)                            {                                Align(n.data).execute();                                n = n.next;                            }                        };                s.addEventListener(Event.RESIZE, f);                s.addEventListener(FullScreenEvent.FULL_SCREEN, function() : void                {                    s.addEventListener(Event.RENDER, function() : void                    {                        s.removeEventListener(Event.RENDER, arguments.callee);                        f();                    });                });            }                            _auto.push(this);        }    }
}
