package com.imajuk.commands{    import com.imajuk.events.AsyncEvent;	    import flash.events.Event;	    import flash.display.*;    import flash.utils.setTimeout;	    import org.libspark.as3unit.after;    import org.libspark.as3unit.assert.*;    import org.libspark.as3unit.before;    import org.libspark.as3unit.test;        use namespace test;    use namespace before;    use namespace after;    internal class CommandComponentTest extends Sprite    {        private var c:int;        private var s:String;        private var syncCmd:Command;        private var asyncCmd:AsyncTestCommand;        before function setupSample():void        {            c = 0;            s = "0";            syncCmd = new Command(function():void            {                c++;            });                        //このコマンドは500 mSecかけて実行が終了する            asyncCmd = new AsyncTestCommand(function():void            {                c++;                s += String(c);            });        }        /**         * item-item の パラレル実行         */        test function parallelExecute_Item_Item():void        {            var group:CommandComponent = new CommandComposite();            group.add(new CommandLeaf(syncCmd));            group.add(new CommandLeaf(syncCmd));            /**             * コンポジットは内包するアイテムのコマンドが終了するとEvent.COMPLETEを配信する             */            group.addEventListener(Event.COMPLETE, async(function():void            {                assertEquals(2, c);                assertTrue(group.isCompleted);            }, 300));            group.execute();        }        /**         * item-group の パラレル実行         */        test function parallelExecute_Item_Group():void        {            var group:CommandComponent = new CommandComposite();            var childGroup:CommandComponent = new CommandComposite();            group.add(new CommandLeaf(syncCmd));            childGroup.add(new CommandLeaf(syncCmd));            childGroup.add(new CommandLeaf(syncCmd));            group.add(childGroup);					            group.addEventListener(Event.COMPLETE, async(function():void            {                assertEquals(3, c);                assertTrue(group.isCompleted);            }, 300));            group.execute();        }        /**         * group-item の パラレル実行         */        test function parallelExecute_Group_Item():void        {            var group:CommandComponent = new CommandComposite();            var childGroup:CommandComponent = new CommandComposite();            childGroup.add(new CommandLeaf(syncCmd));            childGroup.add(new CommandLeaf(syncCmd));            group.add(childGroup);            group.add(new CommandLeaf(syncCmd));					            group.addEventListener(Event.COMPLETE, async(function():void            {                assertEquals(3, c);                assertTrue(group.isCompleted);            }, 300));            group.execute();        }        /**         * group-group の パラレル実行         */        test function parallelExecute_Group_Group():void        {            var group:CommandComponent = new CommandComposite();            var childGroup1:CommandComponent = new CommandComposite();            var childGroup2:CommandComponent = new CommandComposite();            childGroup1.add(new CommandLeaf(syncCmd));            childGroup1.add(new CommandLeaf(syncCmd));            childGroup2.add(new CommandLeaf(syncCmd));            childGroup2.add(new CommandLeaf(syncCmd));            group.add(childGroup1);            group.add(childGroup2);					            group.addEventListener(Event.COMPLETE, async(function():void            {                assertEquals(4, c);                assertTrue(group.isCompleted);            }, 300));            group.execute();        }        /**         * item-item の シーケンシャル実行         * 同期コマンドでは、外から見た場合、パラレル実行とシーケンシャル実行の見分けがつかないため         * 非同期コマンドを使用する         */        test function secuencialExecute_Item_Item():void        {            var group:CommandComponent = new CommandComposite();            assertFalse(group.sequential);            group.sequential = true;            assertTrue(group.sequential);            group.add(new CommandLeaf(asyncCmd));            group.add(new CommandLeaf(asyncCmd));            group.add(new CommandLeaf(asyncCmd));            group.addEventListener(Event.COMPLETE, async(function():void            {                assertEquals("0123", s);            }, 2000));			            assertEquals("0", s);            setTimeout(function():void            {                //700 mSec 後は、最初のアイテムのみが実行されている                assertEquals("01", s);            }, 700);            setTimeout(function():void            {                //1400 mSec 後は、2番めのアイテムまでが実行されている                assertEquals("012", s);            }, 1400);			            group.execute();        }        /**         * item-Group の シーケンシャル実行         * 同期コマンドでは、外から見た場合、パラレル実行とシーケンシャル実行の見分けがつかないため         * 非同期コマンドを使用する         */        test function secuencialExecute_Item_Group():void        {            var group:CommandComponent = new CommandComposite();            group.sequentialChildren = true;            var groupChild:CommandComponent = new CommandComposite();            groupChild.add(new CommandLeaf(asyncCmd));            groupChild.add(new CommandLeaf(asyncCmd));            group.add(new CommandLeaf(asyncCmd));            group.add(groupChild);            group.addEventListener(Event.COMPLETE, async(function():void            {                assertEquals("0123", s);            }, 2000));            group.execute();			            assertEquals("0", s);            setTimeout(function():void            {                //700 mSec 後は、最初のアイテムのみが実行されている                assertEquals("01", s);            }, 700);            setTimeout(function():void            {                //1400 mSec 後は、2番めのアイテムまでが実行されている                assertEquals("012", s);            }, 1400);        }        /**         * Group-Group の シーケンシャル実行         * 同期コマンドでは、外から見た場合、パラレル実行とシーケンシャル実行の見分けがつかないため         * 非同期コマンドを使用する         */        test function secuencialExecute_Group_Group():void        {            var group:CommandComponent = new CommandComposite();            group.sequentialChildren = true;            var groupChild:CommandComponent = new CommandComposite();            groupChild.add(new CommandLeaf(asyncCmd));            groupChild.add(new CommandLeaf(asyncCmd));			            var groupChild2:CommandComponent = new CommandComposite();            groupChild2.add(new CommandLeaf(asyncCmd));            groupChild2.add(new CommandLeaf(asyncCmd));            group.add(groupChild);            group.add(groupChild2);            group.addEventListener(Event.COMPLETE, async(function():void            {                assertEquals("01234", s);            }, 3000));            group.execute();			            assertEquals("0", s);            setTimeout(function():void            {                //700 mSec 後は、最初のアイテムのみが実行されている                assertEquals("01", s);            }, 700);            setTimeout(function():void            {                //1400 mSec 後は、2番めのアイテムまでが実行されている                assertEquals("012", s);            }, 1400);            setTimeout(function():void            {                //1400 mSec 後は、2番めのアイテムまでが実行されている                assertEquals("0123", s);            }, 1900);        }        /**         * sequentialChildrenプロパティは内包する全ての子のsequentialプロパティを操作する         */        test function sequentialChildren():void        {            var group:CommandComponent = new CommandComposite();            assertFalse(group.sequentialChildren);			            //子供を追加してからsequentialChildrenプロパティを変更            var groupChild:CommandComponent = new CommandComposite();            group.add(groupChild);            group.sequentialChildren = true;            assertTrue(group.sequentialChildren);            assertTrue(group.sequential);            assertTrue(groupChild.sequential);            assertFalse(groupChild.sequentialChildren);			            group.sequentialChildren = false;            assertFalse(group.sequentialChildren);            assertFalse(group.sequential);            assertFalse(groupChild.sequential);			            //sequentialChildrenプロパティを変更してから子供を追加            group.sequentialChildren = true;            var groupChild2:CommandComponent = new CommandComposite();            group.add(groupChild2);            assertTrue(groupChild2.sequential);            var groupChild3:CommandComponent = new CommandComposite();            groupChild2.add(groupChild3);            assertTrue(groupChild3.sequential);        }        test function currentChild():void        {            var group:CommandComponent = new CommandComposite();            var item1:CommandLeaf = new CommandLeaf(asyncCmd);             var item2:CommandLeaf = new CommandLeaf(asyncCmd);             group.add(item1);            group.add(item2);            //パラレル実行時はnullを返す            assertEquals(null, group.currentChild);                        group.sequential = true;            //execute()前はnullを返す            assertEquals(null, group.currentChild);                        item2.addEventListener(AsyncEvent.START, async(function():void            {                assertEquals(item2, group.currentChild);            }), false, 1);            group.execute();                        //pause()中はnullを返す            group.pause();            assertEquals(null, group.currentChild);                        group.resume();            assertEquals(item1, group.currentChild);        }        test function loop():void        {            var group:CommandComponent = new CommandComposite();            var item:CommandLeaf = new CommandLeaf(asyncCmd);            group.add(item);                        group.loop = true;            group.addEventListener(Event.COMPLETE, function():void            {                fail("loop指定されているコマンドはCOMPLETEしない");            });                        group.execute();        }        after function teardownSample():void        {        	syncCmd = null;            c = 0;        }    }}