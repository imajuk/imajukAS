package com.imajuk.threads{    import org.libspark.as3unit.after;    import org.libspark.as3unit.assert.assertEquals;    import org.libspark.as3unit.assert.async;    import org.libspark.as3unit.assert.fail;    import org.libspark.as3unit.before;    import org.libspark.as3unit.test;    import org.libspark.thread.EnterFrameThreadExecutor;    import org.libspark.thread.Thread;    import flash.display.Sprite;    import flash.utils.setTimeout;        use namespace test;        use namespace before;        use namespace after;    internal class InvorkerThreadTest extends Sprite    {    	private var X:int = 7;    	        before function setup() : void        {            if (!Thread.isReady)				Thread.initialize(new EnterFrameThreadExecutor());        }        public function echo(o : Object, s : String) : void        {            o.result = s;                        o.result2 = this;            o.result3 = arguments.callee;            o.result4 = X;            o.result5 = this.X;        }                public function echo2(o : Object) : void        {            o.result = this;            o.result2 = arguments.callee;            o.result3 = X;            o.result4 = this.X;        }                test function thisScopeInMethod() : void        {            var o2 : Object = {};            new InvorkerThread(echo2, o2).start();						var t:InvorkerThreadTest = this;            setTimeout(async(function():void            {                assertEquals(t, o2.result);                assertEquals(echo2, o2.result2);                assertEquals(7, o2.result3);                assertEquals(7, o2.result4);            }), 100);        }        test function callMethodWithParam() : void        {            var o : Object = {};			            new InvorkerThread(echo, o, "okkkk").start();			            setTimeout(async(function():void            {                assertEquals("okkkk", o.result);            }), 100);        }                test function callClosureNoParam() : void        {            var o2 : Object = {};            var f : Function = function():void            {                o2.result = "okkkk";            };			            new InvorkerThread(f).start();			            setTimeout(async(function():void            {                assertEquals("okkkk", o2.result);            }), 100);        }        test function callClosureWithParam() : void        {            var f : Function = function(o : Object, s : String):void            {                o.result = s;            };            var o2 : Object = {};			            new InvorkerThread(f, o2, "okkkk").start();			            setTimeout(async(function():void            {                assertEquals("okkkk", o2.result);            }), 100);        }                test function thisScopeInClosure() : void        {        	var x:int = 9;            var f : Function = function(o : Object):void            {                o.result = this;                o.result2 = arguments.callee;                o.result3 = x;                o.result4 = this.x;            };			            var o2 : Object = {};            new InvorkerThread(f, o2).start();			            setTimeout(async(function():void            {                assertEquals(f, o2.result);                assertEquals(f, o2.result2);                assertEquals(9, o2.result3);                assertEquals(null, o2.result4);            }), 100);        }                test function passNull() : void        {        	try        	{            	new InvorkerThread(null).start();            	fail("this fail() must not be called");        	}        	catch(e:Error)        	{        		assertEquals("recieved null.", e.message);            }        }                after function teardown() : void        {        }    }}